#lang racket

; Вопрос:
; я правильно понимаю что ключевая логика need-reframe? в определенном балансе по сути

; Ответ:
; Да, ты совершенно точно понял:
; в основе need-reframe? лежит баланс между ощущением «рамка работает» и сигналами, что она больше не справляется.

; ⸻

; 🧠 Формулируем чётко:

; need-reframe? — это не бинарный триггер,
; а механизм, оценивающий устойчивость рамки по трем осям:

; 	1.	Покрытие — справляется ли рамка с темой?
; 	2.	Исключения — насколько часто возникают ситуации, которые надо “обходить”?
; 	3.	Свежесть мышления — рождаются ли новые вопросы?

; ⸻

; ⚖️ То есть модель проверяет:

; Параметр	Когда нормально	Когда сигнал к рефрейму
; покрывает?	Да → рамка применима	Нет → рамка сломана
; исключения	Мало → рамка гибкая	Много → рамка начинает ломаться
; вопросов	Есть → мышление живое	Нет → застой, привычка, стазис

; 🔁 И когда баланс нарушается, мы не просто меняем рамку,
; а начинаем сомневаться в том, что она “истинна по умолчанию”.




; Ты хочешь не просто «рефрейминг — да/нет», а модель, чувствительную к типу сигнала, с возможностью:
; 	•	различать, почему рамка больше не работает;
; 	•	использовать это как основу для разных стратегий перехода: мягкий, критический, через конфликт и т.д.


; ⸻

; ✅ 1. Структурируем: три типа сигналов

;; Тип 1: внутренняя гладкость — признак стагнации
(define вопросов-1 0) ; нет новых вопросов
(define повторяемость #t) ; всё звучит знакомо
(define крутится-по-кругу #t)

;; Тип 2: отказ модели — сбои в объяснении
(define исключения-2 3)
(define рационализации #t)
(define перенос-проблем #t)

;; Тип 3: контакт с другим видением — когнитивное трение
(define неуютность #t)
(define эффект-узнавания #t)
(define защита-рамки #t)


;  ✅ 2. Три отдельные функции проверки


;; Проверка на внутреннюю гладкость
(define (reframe-гладкость? вопросов повторяется круг)
  (if (and (zero? вопросов) повторяется круг)
      #t
      #f))


;; Проверка на отказ модели
(define (reframe-отказ? исключения рационализ перенос)
  (if (or (> исключения 2) рационализ перенос)
      #t
      #f))


;; Проверка на конфликт с альтернативой
(define (reframe-конфликт? неуютно узнавание защита)
  (if (or неуютно узнавание защита)
      #t
      #f))



;  ✅ 2. Три отдельные функции проверки

(define (need-reframe? тип)
  (cond
    [(equal? тип 'гладкость)
     (reframe-гладкость? вопросов-1 повторяемость крутится-по-кругу)]
    
    [(equal? тип 'отказ)
     (reframe-отказ? исключения-2 рационализации перенос-проблем)]

    [(equal? тип 'конфликт)
     (reframe-конфликт? неуютность эффект-узнавания защита-рамки)]

    [else
     #f]))



; 🧪 Примеры вызова

(need-reframe? 'гладкость)  ; => #t
(need-reframe? 'отказ)      ; => #t
(need-reframe? 'конфликт)   ; => #t