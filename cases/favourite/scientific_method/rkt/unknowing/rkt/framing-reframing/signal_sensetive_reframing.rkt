#lang racket


; Отлично!
; Ты хочешь не просто «рефрейминг — да/нет», а модель, чувствительную к типу сигнала, с возможностью:
; 	•	различать, почему рамка больше не работает;
; 	•	использовать это как основу для разных стратегий перехода: мягкий, критический, через конфликт и т.д.

; Давай шаг за шагом построим это в понятном тебе стиле — без lambda, с define, cond, if.

; ⸻

; ✅ 1. Структурируем: три типа сигналов

;; Тип 1: внутренняя гладкость — признак стагнации
(define вопросов-1 0) ; нет новых вопросов
(define повторяемость #t) ; всё звучит знакомо
(define крутится-по-кругу #t)

;; Тип 2: отказ модели — сбои в объяснении
(define исключения-2 3)
(define рационализации #t)
(define перенос-проблем #t)

;; Тип 3: контакт с другим видением — когнитивное трение
(define неуютность #t)
(define эффект-узнавания #t)
(define защита-рамки #t)


;  ✅ 2. Три отдельные функции проверки


;; Проверка на внутреннюю гладкость
(define (reframe-гладкость? вопросов повторяется круг)
  (if (and (zero? вопросов) повторяется круг)
      #t
      #f))

;; Проверка на отказ модели
(define (reframe-отказ? исключения рационализ перенос)
  (if (or (> исключения 2) рационализ перенос)
      #t
      #f))

;; Проверка на конфликт с альтернативой
(define (reframe-конфликт? неуютно узнавание защита)
  (if (or неуютно узнавание защита)
      #t
      #f))


;  ✅ 2. Три отдельные функции проверки

(define (need-reframe? тип)
  (cond
    [(equal? тип 'гладкость)
     (reframe-гладкость? вопросов-1 повторяемость крутится-по-кругу)]
    
    [(equal? тип 'отказ)
     (reframe-отказ? исключения-2 рационализации перенос-проблем)]

    [(equal? тип 'конфликт)
     (reframe-конфликт? неуютность эффект-узнавания защита-рамки)]

    [else
     #f]))

; 🧪 Примеры вызова

(need-reframe? 'гладкость)  ; => #t
(need-reframe? 'отказ)      ; => #t
(need-reframe? 'конфликт)   ; => #t